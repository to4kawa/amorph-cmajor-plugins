<?xml version="1.0" encoding="UTF-8"?>

<AmorphAlgorithm name="Shape Wave Visualizer (FX)" date="2026-02-14T13:43:47.261+09:00">
  <PresentationConfig title="Shape Wave Visualizer (FX)" author="to4kawa" paramCount="4"
                      highlightColour="ffff466e" backgroundColour="ff1e1e1e" autoGenerateUiCode="0"
                      uiScale="1.0" labWidth="1020" labHeight="750" presentationWidth="980"
                      presentationHeight="1280">
    <ParameterNames>
      <Param index="0" name="Palette"/>
      <Param index="1" name="Intensity"/>
      <Param index="2" name="Shape"/>
      <Param index="3" name="Randomness"/>
      <Param index="4" name="Param 5"/>
      <Param index="5" name="Param 6"/>
      <Param index="6" name="Param 7"/>
      <Param index="7" name="Param 8"/>
      <Param index="8" name="Param 9"/>
      <Param index="9" name="Param 10"/>
      <Param index="10" name="Param 11"/>
      <Param index="11" name="Param 12"/>
      <Param index="12" name="Param 13"/>
      <Param index="13" name="Param 14"/>
      <Param index="14" name="Param 15"/>
      <Param index="15" name="Param 16"/>
    </ParameterNames>
  </PresentationConfig>
  <Code>// V2 processor (FX pass-through) + 4 params
processor ParticleVisualizerOnlyFX
{
    input  stream float&lt;2&gt; in;
    output stream float&lt;2&gt; out;

    input event float param1  [[ name: &quot;Palette&quot;,    min: 0.0, max: 1.0, init: 0.10, step: 0.01 ]];
    input event float param2  [[ name: &quot;Intensity&quot;,  min: 0.0, max: 1.0, init: 0.55, step: 0.01 ]];
    input event float param3  [[ name: &quot;Shape&quot;,      min: 0.0, max: 1.0, init: 0.20, step: 0.01 ]];
    input event float param4  [[ name: &quot;Randomness&quot;, min: 0.0, max: 1.0, init: 0.25, step: 0.01 ]];


    float k1=0.10f, k2=0.55f, k3=0.20f, k4=0.25f;

    event param1 (float v) { k1 = v; }
    event param2 (float v) { k2 = v; }
    event param3 (float v) { k3 = v; }
    event param4 (float v) { k4 = v; }

    void main()
    {
        loop
        {
            float&lt;2&gt; dry = in;
            float keepAlive = (k1+k2+k3+k4) * 0.0f;
            out &lt;- dry + float&lt;2&gt;(keepAlive, keepAlive);
            advance();
        }
    }
}
</Code>
  <UICode>// @amorph-visualizer-ui
// Visualizer-only (FX pass-through) + 4 knobs (Palette / Intensity / Shape / Randomness)
//
// Audio source:
// - Listens to processor endpoint &quot;out&quot; and normalizes payload into mono (Float32/Int16/ArrayBuffer/Array)
// - Runs FFT (radix-2) and derives:
//   - broadband energy (0..1) for general intensity
//   - band energies (0..1): Kick / Mid / Hat from FFT magnitudes
// - Band energies are shaped with short Attack/Release envelope followers for tighter sync
//
// Mode:
// - param4 Mode (0/1): 0 = Particles, 1 = Tiles (Mosaic)
// - In Tiles mode, particles are not accumulated (perf-first). Sparkle is a lightweight highlight add.
//
// Color system (kept from V1):
// - Dictionary &#215; temperature band &#215; weighted pick (Gaussian around Temp)
// - &quot;Lost Jump&quot;: occasional hop to neighbor dictionary
// - Similarity avoidance: reroll if too close to recent RGBs
// - Neighbor drift: picks a second nearby color and smoothly mixes based on Temp offset

class DialControl
{
    constructor (options)
    {
        this.patchConnection = options.patchConnection;
        this.param = options.param;
        this.knob = options.knob;
        this.valueLabel = options.valueLabel;
        this.formatValue = options.formatValue;
        this.onChange = options.onChange;
        this.min = options.min;
        this.max = options.max;
        this.step = options.step;
        this.defaultValue = options.defaultValue;

        if (! (this.max &gt; this.min))
        {
            this.min = 0;
            this.max = 1;
        }

        if (! (this.step &gt; 0))
            this.step = (this.max - this.min) / 100;
        if (! (this.step &gt; 0))
            this.step = 0.01;

        this.value = Number.isFinite(this.defaultValue) ? this.defaultValue : this.min;
        this.dragging = false;
        this.startValue = this.value;
        this.startY = 0;
        this.activePointerId = null;

        this.knob.addEventListener(&quot;pointerdown&quot;, (e) =&gt; this.onPointerDown(e));
        this.knob.addEventListener(&quot;pointermove&quot;, (e) =&gt; this.onPointerMove(e));
        this.knob.addEventListener(&quot;pointerup&quot;, (e) =&gt; this.onPointerUp(e));
        this.knob.addEventListener(&quot;pointercancel&quot;, (e) =&gt; this.onPointerUp(e));
        this.knob.addEventListener(&quot;lostpointercapture&quot;, () =&gt; this.cancelDrag());
        this.knob.addEventListener(&quot;dragstart&quot;, (e) =&gt; e.preventDefault());
        this.knob.addEventListener(&quot;dblclick&quot;, () =&gt; this.setValue(this.defaultValue, true));

        // &#9989; Fix &quot;weird default&quot;: force normalized visuals + label immediately
        this.setValue(this.value, false);
    }

    clamp (value, min, max) { return Math.max(min, Math.min(max, value)); }

    quantize (value)
    {
        if (!this.step || this.step &lt;= 0) return value;
        const steps = Math.round((value - this.min) / this.step);
        return this.min + steps * this.step;
    }

    setValue (value, notify)
    {
        const numericValue = Number.isFinite(value) ? value : this.defaultValue;
        const clamped = this.clamp(this.quantize(numericValue), this.min, this.max);
        this.value = clamped;
        this.updateVisuals();

        if (this.valueLabel)
            this.valueLabel.textContent = this.formatValue(this.value);

        if (this.onChange)
            this.onChange(this.value);

        if (notify === true)
            this.patchConnection.sendEventOrValue(this.param, this.value);
    }

    updateVisuals()
    {
        const denom = (this.max - this.min);
        const norm = denom &gt; 0 ? (this.value - this.min) / denom : 0;
        const clampedNorm = this.clamp(norm, 0, 1);
        const angle = -135 + clampedNorm * 270;
        this.knob.style.setProperty(&quot;--angle&quot;, &#96;${angle}deg&#96;);
        this.knob.style.setProperty(&quot;--norm&quot;, &#96;${clampedNorm}&#96;);
    }

    setDraggingState (isDragging)
    {
        this.dragging = isDragging;
        this.knob.classList.toggle(&quot;is-dragging&quot;, isDragging);

        const root = this.knob.closest(&quot;.auto-ui-root&quot;);
        if (root)
            root.classList.toggle(&quot;is-dragging&quot;, isDragging);
    }

    cancelDrag ()
    {
        this.setDraggingState(false);
        this.activePointerId = null;
    }

    onPointerDown (e)
    {
        if ((e.button !== undefined &amp;&amp; e.button !== 0) || e.isPrimary === false)
            return;

        e.preventDefault();
        e.stopPropagation();

        this.startY = e.clientY;
        this.startValue = this.value;
        this.activePointerId = e.pointerId;
        this.dragging = true;
        this.setDraggingState(true);

        try { this.knob.setPointerCapture(e.pointerId); } catch (_) {}
    }

    onPointerMove (e)
    {
        if (!this.dragging || this.activePointerId !== e.pointerId)
            return;

        e.preventDefault();

        const delta = this.startY - e.clientY;
        const range = this.max - this.min;

        const sensitivity = range / 240;
        const fine = e.shiftKey ? 0.2 : 1.0;
        const nextValue = this.startValue + delta * sensitivity * fine;
        this.setValue(nextValue, true);
    }

    onPointerUp (e)
    {
        if (!this.dragging || this.activePointerId !== e.pointerId)
            return;

        e.preventDefault();
        e.stopPropagation();

        this.setDraggingState(false);
        this.activePointerId = null;

        try
        {
            if (this.knob.hasPointerCapture(e.pointerId))
                this.knob.releasePointerCapture(e.pointerId);
        }
        catch (_) {}
    }
}

// ======================================================
// Endpoint audio normalization (compact + robust enough)
// ======================================================

function normalizeAudioChunk (payload)
{
    const result = { mono: null, sampleRate: undefined };

    const setSampleRate = (sr) =&gt;
    {
        const n = Number(sr);
        if (Number.isFinite(n) &amp;&amp; n &gt; 1000 &amp;&amp; n &lt; 768000)
            result.sampleRate = n;
    };

    const i16ToF32 = (i16) =&gt;
    {
        const f = new Float32Array(i16.length);
        for (let i = 0; i &lt; i16.length; i++)
            f[i] = i16[i] / 32768;
        return f;
    };

    const toF32 = (x) =&gt;
    {
        if (!x) return null;
        if (x instanceof Float32Array) return x;
        if (x instanceof Int16Array) return i16ToF32(x);

        if (x instanceof ArrayBuffer)
        {
            if ((x.byteLength % 4) === 0) return new Float32Array(x);
            if ((x.byteLength % 2) === 0) return i16ToF32(new Int16Array(x));
            return null;
        }

        if (ArrayBuffer.isView(x))
        {
            if (x instanceof DataView) return null;
            if (x instanceof Float32Array) return x;
            if (x instanceof Int16Array) return i16ToF32(x);

            if ((x.byteLength % 4) === 0)
                return new Float32Array(x.buffer, x.byteOffset, Math.floor(x.byteLength / 4));

            const out = new Float32Array(x.length || 0);
            for (let i = 0; i &lt; out.length; i++)
                out[i] = Number(x[i]) || 0;
            return out;
        }

        if (Array.isArray(x))
        {
            const out = new Float32Array(x.length);
            for (let i = 0; i &lt; out.length; i++)
                out[i] = Number(x[i]) || 0;
            return out;
        }

        return null;
    };

    const toMonoFromChannels = (channels) =&gt;
    {
        if (!Array.isArray(channels) || channels.length === 0) return null;

        const a = toF32(channels[0]);
        const b = toF32(channels[1] ?? channels[0]);
        if (!a || !b) return null;

        const n = Math.min(a.length, b.length);
        if (!(n &gt; 0)) return null;

        const mono = new Float32Array(n);
        for (let i = 0; i &lt; n; i++)
            mono[i] = 0.5 * ((a[i] || 0) + (b[i] || 0));

        return mono;
    };

    const walk = (node) =&gt;
    {
        if (node == null) return null;

        if (node.sampleRate != null) setSampleRate(node.sampleRate);

        if (node.left != null &amp;&amp; node.right != null)
        {
            const m = toMonoFromChannels([node.left, node.right]);
            if (m) return m;
        }

        for (const k of [&quot;data&quot;, &quot;samples&quot;, &quot;frames&quot;, &quot;audio&quot;, &quot;pcm&quot;, &quot;buffer&quot;])
        {
            if (node[k] != null)
            {
                if (Array.isArray(node[k]) &amp;&amp; (Array.isArray(node[k][0]) || ArrayBuffer.isView(node[k][0])))
                {
                    const m = toMonoFromChannels(node[k]);
                    if (m) return m;
                }

                const f = toF32(node[k]);
                if (f) return f;
            }
        }

        const direct = toF32(node);
        if (direct) return direct;

        if (typeof node === &quot;object&quot;)
        {
            for (const k of [&quot;payload&quot;, &quot;value&quot;, &quot;chunk&quot;, &quot;detail&quot;, &quot;event&quot;])
            {
                if (node[k] != null)
                {
                    const m = walk(node[k]);
                    if (m) return m;
                }
            }
        }

        return null;
    };

    result.mono = walk(payload);
    return result;
}

// ======================================================
// Simple FFT (radix-2, real input)
// ======================================================

class FFT
{
    constructor (fftSize)
    {
        this.N = fftSize;
        this.bits = Math.round(Math.log2(this.N));

        this.rev = new Uint32Array(this.N);
        for (let i = 0; i &lt; this.N; i++)
        {
            let x = i;
            let y = 0;
            for (let b = 0; b &lt; this.bits; b++)
            {
                y = (y &lt;&lt; 1) | (x &amp; 1);
                x &gt;&gt;= 1;
            }
            this.rev[i] = y &gt;&gt;&gt; 0;
        }

        this.cos = new Float32Array(this.N / 2);
        this.sin = new Float32Array(this.N / 2);
        for (let k = 0; k &lt; this.N / 2; k++)
        {
            const a = -2 * Math.PI * k / this.N;
            this.cos[k] = Math.cos(a);
            this.sin[k] = Math.sin(a);
        }

        this.re = new Float32Array(this.N);
        this.im = new Float32Array(this.N);

        this.win = new Float32Array(this.N);
        for (let i = 0; i &lt; this.N; i++)
            this.win[i] = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (this.N - 1));
    }

    forwardReal (x)
    {
        const N = this.N;

        for (let i = 0; i &lt; N; i++)
        {
            const j = this.rev[i];
            this.re[i] = (x[j] || 0) * this.win[j];
            this.im[i] = 0;
        }

        for (let size = 2; size &lt;= N; size &lt;&lt;= 1)
        {
            const half = size &gt;&gt;&gt; 1;
            const step = N / size;

            for (let i = 0; i &lt; N; i += size)
            {
                let k = 0;
                for (let j = 0; j &lt; half; j++)
                {
                    const tRe = this.re[i + j + half];
                    const tIm = this.im[i + j + half];

                    const c = this.cos[k];
                    const s = this.sin[k];

                    const mRe = tRe * c - tIm * s;
                    const mIm = tRe * s + tIm * c;

                    const uRe = this.re[i + j];
                    const uIm = this.im[i + j];

                    this.re[i + j] = uRe + mRe;
                    this.im[i + j] = uIm + mIm;
                    this.re[i + j + half] = uRe - mRe;
                    this.im[i + j + half] = uIm - mIm;

                    k += step;
                }
            }
        }

        return { re: this.re, im: this.im };
    }
}

// ======================================================
// Visualizer utilities: Dictionary &#215; Temp &#215; Weighted Pick (+ Lost Jump)
// ======================================================

function clamp01 (x) { return Math.max(0, Math.min(1, x)); }
function lerp (a, b, t) { return a + (b - a) * t; }

function quantizeIndex01 (x01, count)
{
    if (!(count &gt; 1)) return 0;
    const t = clamp01(x01);
    return Math.max(0, Math.min(count - 1, Math.round(t * (count - 1))));
}

function gaussianBandWeight (tempPos, tempTarget, sigma)
{
    const d = tempPos - tempTarget;
    const denom = 2 * sigma * sigma;
    return Math.exp(-(d * d) / Math.max(1e-9, denom));
}

function rgbToString (rgb, alpha)
{
    const r = Math.max(0, Math.min(255, Math.round(rgb[0] || 0)));
    const g = Math.max(0, Math.min(255, Math.round(rgb[1] || 0)));
    const b = Math.max(0, Math.min(255, Math.round(rgb[2] || 0)));
    return &#96;rgba(${r}, ${g}, ${b}, ${alpha})&#96;;
}

function rgbDistance (a, b)
{
    const dr = (a[0] || 0) - (b[0] || 0);
    const dg = (a[1] || 0) - (b[1] || 0);
    const db = (a[2] || 0) - (b[2] || 0);
    return Math.sqrt(dr * dr + dg * dg + db * db);
}

// ======================================================
// V2 ADD: band energy helpers (Kick/Mid/Hat)
// ======================================================

function hzToBin (hz, sr, fftSize)
{
    const nyq = sr * 0.5;
    const bins = fftSize &gt;&gt; 1;
    const t = Math.max(0, Math.min(1, hz / Math.max(1e-6, nyq)));
    return Math.max(0, Math.min(bins - 1, Math.round(t * (bins - 1))));
}

function bandEnergy (mag, sr, fftSize, hzLo, hzHi)
{
    const lo = hzToBin(hzLo, sr, fftSize);
    const hi = hzToBin(hzHi, sr, fftSize);
    const a = Math.min(lo, hi), b = Math.max(lo, hi);

    let sum = 0;
    let n = 0;
    for (let i = a; i &lt;= b; i++) { sum += mag[i] || 0; n++; }

    const mean = sum / Math.max(1, n);
    // same family as broadband energy (tune later if needed)
    return clamp01((Math.log10(1e-6 + mean) + 5.2) / 1.25);
}

// ======================================================
// V2 ADD: Attack/Release follower
// ======================================================

class ARFollower
{
    constructor() { this.v = 0; }

    tick (x01, attack01, release01)
    {
        const x = clamp01(x01);

        // attack: 0 slow .. 1 fast
        const a = lerp(0.08, 0.35, clamp01(attack01));
        // release: 0 short .. 1 long
        const r = lerp(0.35, 0.98, clamp01(release01));

        if (x &gt; this.v) this.v = this.v * (1 - a) + x * a;
        else            this.v = this.v * r + x * (1 - r);

        return this.v;
    }
}

function makeGenres ()
{
    return [
        {
            label: &quot;Gems&quot;,
            colors: [
                { name: &quot;Amber&quot;,       rgb: [255, 166,  74], tempPos: 0.08, weightBase: 1.00 },
                { name: &quot;Garnet&quot;,      rgb: [155,  24,  49], tempPos: 0.18, weightBase: 0.85 },
                { name: &quot;Citrine&quot;,     rgb: [245, 196,  66], tempPos: 0.16, weightBase: 0.95 },
                { name: &quot;Rose Quartz&quot;, rgb: [234, 154, 174], tempPos: 0.28, weightBase: 0.80 },
                { name: &quot;Jade&quot;,        rgb: [ 80, 184, 126], tempPos: 0.52, weightBase: 0.85 },
                { name: &quot;Peridot&quot;,     rgb: [173, 226,  64], tempPos: 0.44, weightBase: 0.75 },
                { name: &quot;Opal&quot;,        rgb: [210, 226, 231], tempPos: 0.62, weightBase: 0.70 },
                { name: &quot;Aquamarine&quot;,  rgb: [ 96, 200, 218], tempPos: 0.74, weightBase: 0.80 },
                { name: &quot;Sapphire&quot;,    rgb: [ 35,  87, 205], tempPos: 0.90, weightBase: 0.95 },
                { name: &quot;Amethyst&quot;,    rgb: [151,  90, 214], tempPos: 0.80, weightBase: 0.85 },
                { name: &quot;Silver&quot;,      rgb: [200, 206, 214], tempPos: 0.78, weightBase: 0.70 },
                { name: &quot;Ice&quot;,         rgb: [180, 240, 255], tempPos: 0.98, weightBase: 0.78 }
            ]
        },
        {
            label: &quot;Plants&quot;,
            colors: [
                { name: &quot;Marigold&quot;,    rgb: [246, 168,  52], tempPos: 0.12, weightBase: 0.90 },
                { name: &quot;Terracotta&quot;,  rgb: [197,  92,  64], tempPos: 0.18, weightBase: 0.80 },
                { name: &quot;Blush&quot;,       rgb: [238, 151, 156], tempPos: 0.28, weightBase: 0.78 },
                { name: &quot;Leaf&quot;,        rgb: [ 88, 170,  88], tempPos: 0.50, weightBase: 1.05 },
                { name: &quot;Moss&quot;,        rgb: [ 78, 120,  76], tempPos: 0.58, weightBase: 0.85 },
                { name: &quot;Mint&quot;,        rgb: [131, 224, 190], tempPos: 0.66, weightBase: 0.78 },
                { name: &quot;Eucalyptus&quot;,  rgb: [ 99, 173, 161], tempPos: 0.72, weightBase: 0.80 },
                { name: &quot;Lavender&quot;,    rgb: [173, 142, 230], tempPos: 0.78, weightBase: 0.70 },
                { name: &quot;Bluebell&quot;,    rgb: [ 92, 126, 235], tempPos: 0.86, weightBase: 0.72 },
                { name: &quot;Night Fern&quot;,  rgb: [ 33,  60,  58], tempPos: 0.90, weightBase: 0.60 }
            ]
        },
        {
            label: &quot;Materials&quot;,
            colors: [
                { name: &quot;Brass&quot;,       rgb: [210, 171,  63], tempPos: 0.16, weightBase: 0.95 },
                { name: &quot;Copper&quot;,      rgb: [187,  88,  53], tempPos: 0.20, weightBase: 0.90 },
                { name: &quot;Leather&quot;,     rgb: [141,  84,  52], tempPos: 0.30, weightBase: 0.80 },
                { name: &quot;Concrete&quot;,    rgb: [150, 156, 162], tempPos: 0.62, weightBase: 0.85 },
                { name: &quot;Steel&quot;,       rgb: [170, 178, 190], tempPos: 0.74, weightBase: 0.95 },
                { name: &quot;Carbon&quot;,      rgb: [ 44,  49,  58], tempPos: 0.82, weightBase: 0.75 },
                { name: &quot;Ceramic&quot;,     rgb: [224, 230, 235], tempPos: 0.70, weightBase: 0.70 },
                { name: &quot;Titanium&quot;,    rgb: [188, 200, 214], tempPos: 0.86, weightBase: 0.82 },
                { name: &quot;Glass&quot;,       rgb: [165, 232, 238], tempPos: 0.92, weightBase: 0.72 }
            ]
        },
        {
            label: &quot;Foods&quot;,
            colors: [
                { name: &quot;Mango&quot;,       rgb: [255, 163,  63], tempPos: 0.10, weightBase: 1.00 },
                { name: &quot;Chili&quot;,       rgb: [200,  28,  34], tempPos: 0.12, weightBase: 0.75 },
                { name: &quot;Honey&quot;,       rgb: [245, 197,  74], tempPos: 0.18, weightBase: 0.95 },
                { name: &quot;Caramel&quot;,     rgb: [194, 112,  61], tempPos: 0.24, weightBase: 0.90 },
                { name: &quot;Mocha&quot;,       rgb: [124,  78,  59], tempPos: 0.34, weightBase: 0.78 },
                { name: &quot;Matcha&quot;,      rgb: [108, 170,  72], tempPos: 0.52, weightBase: 0.88 },
                { name: &quot;Soda&quot;,        rgb: [ 92, 205, 210], tempPos: 0.76, weightBase: 0.78 },
                { name: &quot;Blueberry&quot;,   rgb: [ 68,  92, 210], tempPos: 0.88, weightBase: 0.90 },
                { name: &quot;Ice Milk&quot;,    rgb: [220, 238, 245], tempPos: 0.96, weightBase: 0.70 }
            ]
        },
        {
            label: &quot;Neon&quot;,
            colors: [
                { name: &quot;Neon Amber&quot;,  rgb: [255, 184,  51], tempPos: 0.14, weightBase: 0.85 },
                { name: &quot;Neon Pink&quot;,   rgb: [255,  72, 196], tempPos: 0.34, weightBase: 1.10 },
                { name: &quot;Neon Lime&quot;,   rgb: [178, 255,  51], tempPos: 0.46, weightBase: 0.95 },
                { name: &quot;Neon Cyan&quot;,   rgb: [ 65, 245, 255], tempPos: 0.74, weightBase: 1.05 },
                { name: &quot;Neon Blue&quot;,   rgb: [ 56, 120, 255], tempPos: 0.88, weightBase: 0.98 },
                { name: &quot;Neon Violet&quot;, rgb: [160,  74, 255], tempPos: 0.84, weightBase: 0.90 }
            ]
        },
        {
            label: &quot;Pastels&quot;,
            colors: [
                { name: &quot;Peach&quot;,       rgb: [255, 198, 170], tempPos: 0.18, weightBase: 1.00 },
                { name: &quot;Butter&quot;,      rgb: [252, 238, 170], tempPos: 0.22, weightBase: 0.92 },
                { name: &quot;Lilac&quot;,       rgb: [214, 188, 255], tempPos: 0.72, weightBase: 0.92 },
                { name: &quot;Sky&quot;,         rgb: [188, 226, 255], tempPos: 0.92, weightBase: 0.98 },
                { name: &quot;Mint Cream&quot;,  rgb: [204, 252, 230], tempPos: 0.86, weightBase: 0.88 },
                { name: &quot;Fog&quot;,         rgb: [230, 236, 244], tempPos: 0.78, weightBase: 0.82 }
            ]
        }
    ];
}

function pickWeightedIndex (weights)
{
    let sum = 0;
    for (let i = 0; i &lt; weights.length; i++)
        sum += Math.max(0, weights[i] || 0);

    if (!(sum &gt; 0))
        return Math.max(0, Math.min(weights.length - 1, Math.floor(Math.random() * weights.length)));

    let r = Math.random() * sum;
    for (let i = 0; i &lt; weights.length; i++)
    {
        r -= Math.max(0, weights[i] || 0);
        if (r &lt;= 0)
            return i;
    }

    return weights.length - 1;
}

function neighborIndex (idx, len, dir)
{
    if (!(len &gt; 0)) return 0;
    const d = dir &gt;= 0 ? 1 : -1;
    return Math.max(0, Math.min(len - 1, idx + d));
}

function starPath (ctx, cx, cy, r, points)
{
    const spikes = Math.max(4, Math.min(8, points | 0));
    const inner = r * 0.46;
    let rot = Math.PI / 2 * 3;

    ctx.beginPath();
    ctx.moveTo(cx, cy - r);

    for (let i = 0; i &lt; spikes; i++)
    {
        const x1 = cx + Math.cos(rot) * r;
        const y1 = cy + Math.sin(rot) * r;
        ctx.lineTo(x1, y1);
        rot += Math.PI / spikes;

        const x2 = cx + Math.cos(rot) * inner;
        const y2 = cy + Math.sin(rot) * inner;
        ctx.lineTo(x2, y2);
        rot += Math.PI / spikes;
    }

    ctx.closePath();
}

class TileMosaic
{
    constructor (canvas, pickFn)
    {
        this.canvas = canvas;
        this.ctx = canvas.getContext(&quot;2d&quot;, { alpha: true, desynchronized: true });
        this.pickFn = pickFn;
        this.tiles = [];
        this.cols = 24;
        this.rows = 24;
        this.time = 0;
        this._w = 0;
        this._h = 0;
        this.reseed();
    }

    reseed ()
    {
        const w = this.canvas.width;
        const h = this.canvas.height;
        this._w = w;
        this._h = h;

        this.tiles = [];
        for (let y = 0; y &lt; this.rows; y++)
        for (let x = 0; x &lt; this.cols; x++)
        {
            this.tiles.push({
                x, y,
                phase: Math.random() * Math.PI * 2,
                jitter: (Math.random() - 0.5),
                glow: 0,
                // color-transition motion
                mix: Math.random(),
                mixVel: 0.06 + Math.random() * 0.22,
                // breathing phase seed
                breatheSeed: Math.random() * Math.PI * 2
            });
        }
    }

    setGridByDensity (density01)
    {
        const t = clamp01(density01);
        const n = Math.round(lerp(14, 48, t));
        const cols = n;
        const rows = n;

        const sizeChanged = (cols !== this.cols || rows !== this.rows);
        const whChanged = (this.canvas.width !== this._w || this.canvas.height !== this._h);

        if (sizeChanged)
        {
            this.cols = cols;
            this.rows = rows;
        }

        if (sizeChanged || whChanged)
            this.reseed();
    }

    draw (dt, params, kick, mid, hat)
    {
        this.time += dt;

        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;

        this.setGridByDensity(params.density ?? 0.55);

        const pick = this.pickFn();
        const A = pick.rgb;
        const B = pick.rgb2;

        // Clear (Tiles: less trail)
        ctx.save();
        ctx.globalCompositeOperation = &quot;source-over&quot;;
        ctx.fillStyle = &quot;rgba(8, 10, 16, 0.55)&quot;;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();

        const cw = w / this.cols;
        const ch = h / this.rows;

        const grout   = clamp01(params.grout ?? 0.55);
        const jitter  = clamp01(params.jitter ?? 0.35);
        const sparkle = clamp01(params.sparkle ?? 0.25);

        // Kick = grout emphasis / flash
        const lineW = lerp(0.7, 4.4, grout) * (1 + kick * 2.2);
        ctx.lineWidth = lineW;
        ctx.lineJoin = &quot;round&quot;;

        for (let i = 0; i &lt; this.tiles.length; i++)
        {
            const t = this.tiles[i];
            const px = t.x * cw;
            const py = t.y * ch;

            // Mid = breathing
            const breathe = 0.50 + 0.50 * Math.sin(this.time * (1.25 + mid * 2.4) + t.breatheSeed);

            // Hat = local sparkle intensity memory
            t.glow = clamp01(t.glow * 0.90 + hat * 0.26);

            const accel = 1 + kick * 2.0 + hat * 0.8;
            t.mix += dt * t.mixVel * accel;
            const tri = 1 - Math.abs(1 - (t.mix % 2));
            const mix01 = clamp01(
                tri * (0.35 + 0.65 * breathe)
              + (mid * 0.18)
              + (hat * 0.10)
              + (kick * 0.12)
            );

            const jx = (Math.sin(t.phase + this.time * 0.9) * 0.5 + t.jitter) * jitter * cw * 0.22;
            const jy = (Math.cos(t.phase + this.time * 0.7) * 0.5 + t.jitter) * jitter * ch * 0.22;

            const base = [
                lerp(A[0], B[0], mix01),
                lerp(A[1], B[1], mix01),
                lerp(A[2], B[2], mix01)
            ];
            const rgb = [
                base[0] * (0.70 + 0.60 * breathe) + 85 * t.glow,
                base[1] * (0.70 + 0.60 * breathe) + 85 * t.glow,
                base[2] * (0.70 + 0.60 * breathe) + 85 * t.glow
            ];

            ctx.fillStyle = rgbToString(rgb, 0.78);
            ctx.beginPath();
            ctx.rect(px + jx, py + jy, cw, ch);
            ctx.fill();

            // grout line
            const groutGlow = clamp01(0.10 + kick * 0.75);
            ctx.strokeStyle = `rgba(0,0,0,${0.62 - groutGlow * 0.22})`;
            ctx.strokeRect(px + jx, py + jy, cw, ch);

            // sparkle dot (Hat)
            if (sparkle &gt; 0 &amp;&amp; Math.random() &lt; sparkle * (0.02 + hat * 0.06))
            {
                ctx.fillStyle = &quot;rgba(235,245,255,0.75)&quot;;
                const sx = px + cw * Math.random();
                const sy = py + ch * Math.random();
                ctx.beginPath();
                ctx.arc(sx, sy, 0.9 + hat * 2.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // vignette (keep the look)
        ctx.save();
        const g = ctx.createRadialGradient(w * 0.5, h * 0.5, 0, w * 0.5, h * 0.5, w * 0.55);
        g.addColorStop(0, &quot;rgba(0,0,0,0)&quot;);
        g.addColorStop(1, &quot;rgba(0,0,0,0.42)&quot;);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
    }
}

class ParticleVisualizer
{
    constructor (canvas, labelEl)
    {
        this.canvas = canvas;
        this.ctx = canvas.getContext(&quot;2d&quot;, { alpha: true, desynchronized: true });
        this.labelEl = labelEl;

        this.fftSize = 2048;
        this.hop = 512;
        this.ring = new Float32Array(this.fftSize * 4);
        this.rw = 0;
        this.rc = 0;
        this.frame = new Float32Array(this.fftSize);
        this.fft = new FFT(this.fftSize);
        this.mag = new Float32Array(this.fftSize &gt;&gt; 1);

        this.sampleRate = 48000;
        this.energy = 0;
        this.energySmooth = 0;
        this.energySmoothPrev = 0;

        this.params = {
            palette: 0.10,
            intensity: 0.55,
            shape: 0.20,
            randomness: 0.25
        };

        this.stablePalette = this.params.palette;
        this.stableIntensity = this.params.intensity;
        this.stableShape = this.params.shape;

        this.colorPhase = 0;
        this.shapePhase = 0;
        this.rot = 0;

        this.bgTime = 0;
        this.bgSweepHz = 2.0;

        this.maxParticles = 256;
        this.particles = new Array(this.maxParticles).fill(0).map(() => ({
            alive: false,
            x: 0,
            y: 0,
            dirX: 0,
            dirY: 0,
            vx: 0,
            vy: 0,
            wobblePhase: 0,
            wobbleRate: 0,
            wobbleAmp: 0,
            life: 0,
            age: 0,
            size: 0,
            col: [0, 0, 0],
            spin: 0,
            rot: 0,
            maxRadius: 0
        }));
        this.particleHead = 0;
        this.spawnCooldown = 0;
        this.randomnessSmooth = this.params.randomness;

        this.paletteSets = [
            [[245, 82, 118], [255, 196, 84], [139, 225, 255], [136, 102, 255]],
            [[71, 138, 255], [83, 230, 176], [227, 255, 102], [255, 255, 255]],
            [[255, 107, 80], [255, 156, 53], [255, 227, 131], [127, 211, 255]],
            [[178, 120, 255], [88, 67, 232], [50, 30, 138], [198, 159, 255]]
        ];

        this.shapeNames = [&quot;Triangle&quot;, &quot;Circle&quot;, &quot;Square&quot;, &quot;Star&quot;];

        this._raf = 0;
        this._lastT = 0;

        this.ro = new ResizeObserver(() =&gt; this.resizeToSquare());
        this.ro.observe(canvas);
        this.resizeToSquare();

        this.loop = (t) =&gt;
        {
            this._raf = requestAnimationFrame(this.loop);
            const dtMs = (t - this._lastT) || 16.7;
            this._lastT = t;
            const dt = Math.max(0.001, Math.min(0.050, dtMs / 1000));
            this.draw(dt);
        };

        this._raf = requestAnimationFrame(this.loop);
    }

    destroy ()
    {
        cancelAnimationFrame(this._raf);
        this._raf = 0;
        try { this.ro.disconnect(); } catch (_) {}
    }

    wake ()
    {
        this.resizeToSquare();
        if (!this._raf)
        {
            this._lastT = 0;
            this._raf = requestAnimationFrame(this.loop);
        }
    }

    setParam (name, v)
    {
        if (name === &quot;palette&quot;) this.params.palette = clamp01(v);
        if (name === &quot;intensity&quot;) this.params.intensity = clamp01(v);
        if (name === &quot;shape&quot;) this.params.shape = clamp01(v);
        if (name === &quot;randomness&quot;) this.params.randomness = clamp01(v);
    }

    resizeToSquare ()
    {
        const rect = this.canvas.getBoundingClientRect();
        const side = Math.max(1, Math.floor(Math.min(rect.width, rect.height)));
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

        const w = Math.floor(side * dpr);
        const h = Math.floor(side * dpr);

        if (this.canvas.width !== w || this.canvas.height !== h)
        {
            this.canvas.width = w;
            this.canvas.height = h;
        }
    }

    pushMonoSamples (mono)
    {
        for (let i = 0; i &lt; mono.length; i++)
        {
            this.ring[this.rw] = mono[i];
            this.rw = (this.rw + 1) % this.ring.length;
            this.rc = Math.min(this.ring.length, this.rc + 1);
        }

        while (this.rc &gt;= this.fftSize)
        {
            const start = (this.rw - this.fftSize + this.ring.length) % this.ring.length;
            for (let i = 0; i &lt; this.fftSize; i++)
                this.frame[i] = this.ring[(start + i) % this.ring.length];

            this.computeEnergy();
            this.rc = Math.max(0, this.rc - this.hop);
        }
    }

    computeEnergy ()
    {
        const { re, im } = this.fft.forwardReal(this.frame);
        const bins = this.mag.length;
        const invN = 1.0 / this.fftSize;

        let sum = 0;
        const lo = Math.floor(bins * 0.04);
        const hi = Math.floor(bins * 0.72);

        for (let i = 0; i &lt; bins; i++)
        {
            const rr = re[i] * invN;
            const ii = im[i] * invN;
            const m = Math.sqrt(rr * rr + ii * ii);
            this.mag[i] = m;
            if (i &gt;= lo &amp;&amp; i &lt;= hi) sum += m;
        }

        const mean = sum / Math.max(1, (hi - lo + 1));
        this.energy = clamp01((Math.log10(1e-6 + mean) + 5.2) / 1.4);
    }

    smoothToward (cur, target, rate, dt)
    {
        const k = 1.0 - Math.exp(-Math.max(0.01, rate) * dt);
        return cur + (target - cur) * clamp01(k);
    }

    sampleShape (shapeId, t, radius)
    {
        const a = t * Math.PI * 2;
        const c = Math.cos(a);
        const s = Math.sin(a);

        if (shapeId === 1)
            return [c * radius, s * radius];

        if (shapeId === 0)
        {
            const verts = [
                [0, -radius],
                [radius * 0.8660254, radius * 0.5],
                [-radius * 0.8660254, radius * 0.5]
            ];
            const seg = Math.floor(t * 3) % 3;
            const local = (t * 3) - Math.floor(t * 3);
            const a0 = verts[seg];
            const b0 = verts[(seg + 1) % 3];
            return [lerp(a0[0], b0[0], local), lerp(a0[1], b0[1], local)];
        }

        if (shapeId === 2)
        {
            const side = t * 4;
            const seg = Math.floor(side) % 4;
            const u = side - Math.floor(side);
            const r = radius;
            if (seg === 0) return [lerp(-r, r, u), -r];
            if (seg === 1) return [r, lerp(-r, r, u)];
            if (seg === 2) return [lerp(r, -r, u), r];
            return [-r, lerp(r, -r, u)];
        }

        const points = 5;
        const inner = radius * 0.45;
        const k = Math.floor(t * points * 2) % (points * 2);
        const u = (t * points * 2) - Math.floor(t * points * 2);
        const angleA = (-Math.PI * 0.5) + (k * Math.PI / points);
        const angleB = (-Math.PI * 0.5) + ((k + 1) * Math.PI / points);
        const rA = (k % 2 === 0) ? radius : inner;
        const rB = ((k + 1) % 2 === 0) ? radius : inner;
        const ax = Math.cos(angleA) * rA;
        const ay = Math.sin(angleA) * rA;
        const bx = Math.cos(angleB) * rB;
        const by = Math.sin(angleB) * rB;
        return [lerp(ax, bx, u), lerp(ay, by, u)];
    }

    paletteColor (t)
    {
        const sets = this.paletteSets;
        const p = clamp01(this.stablePalette);
        const pos = p * (sets.length - 1);
        const i0 = Math.floor(pos);
        const i1 = Math.min(sets.length - 1, i0 + 1);
        const setMix = pos - i0;

        const cidx = t * 3;
        const c0 = Math.floor(cidx) % 4;
        const c1 = (c0 + 1) % 4;
        const local = cidx - Math.floor(cidx);

        const ca = this.blendedRGB(sets[i0][c0], sets[i0][c1], local);
        const cb = this.blendedRGB(sets[i1][c0], sets[i1][c1], local);

        return this.blendedRGB(ca, cb, setMix);
    }

    blendedRGB (a, b, t)
    {
        const tt = clamp01(t);
        return [
            lerp(a[0], b[0], tt),
            lerp(a[1], b[1], tt),
            lerp(a[2], b[2], tt)
        ];
    }

    spawnParticles (onset, shapeId, cx, cy, baseRadius, w, h)
    {
        const jitter = this.randomnessSmooth;
        const count = 1 + Math.round(onset * (4 + this.stableIntensity * 12));
        const speedMin = 38;
        const speedMax = 310;
        const lifeBase = lerp(0.35, 1.2, 0.2 + this.stableIntensity * 0.8);
        const spread = lerp(0.65, 1.0, jitter);
        const tangentialMix = shapeId === 3 ? (0.04 + jitter * 0.12) : 0;
        const screenRadius = Math.sqrt((w * 0.5) * (w * 0.5) + (h * 0.5) * (h * 0.5));
        const maxRadiusBase = lerp(screenRadius * 0.45, screenRadius, intensityBoost);

        for (let i = 0; i &lt; count; i++)
        {
            const p = this.particles[this.particleHead];
            this.particleHead = (this.particleHead + 1) % this.maxParticles;

            const thetaBase = Math.random() * Math.PI * 2;
            const theta = thetaBase + (Math.random() - 0.5) * (1.0 - spread) * Math.PI;
            const intensityCurve = Math.pow(clamp01(this.stableIntensity), 1.7);
            const speed = lerp(speedMin, speedMax, intensityCurve) * lerp(0.75, 1.2, Math.random());
            const dirX = Math.cos(theta);
            const dirY = Math.sin(theta);
            const tanX = -dirY;
            const tanY = dirX;

            p.alive = true;
            p.age = 0;
            p.life = lifeBase * lerp(0.78, 1.22, Math.random() * (0.7 + jitter * 0.3));
            p.size = lerp(1.8, 10.5, intensityBoost) * lerp(0.7, 1.35, Math.random());
            p.rot = Math.random() * Math.PI * 2;
            p.spin = (Math.random() - 0.5) * (1.4 + jitter * 3.2);
            p.dirX = dirX;
            p.dirY = dirY;
            p.wobblePhase = Math.random() * Math.PI * 2;
            p.wobbleRate = lerp(2.5, 11.0, jitter) * lerp(0.8, 1.25, Math.random());
            p.wobbleAmp = lerp(0.0, 130.0, jitter) * lerp(0.65, 1.35, Math.random());
            p.maxRadius = maxRadiusBase * lerp(0.88, 1.15, Math.random());

            const startOffset = baseRadius * (0.02 + Math.random() * 0.03);
            p.x = cx + dirX * startOffset;
            p.y = cy + dirY * startOffset;
            p.vx = (dirX + tanX * tangentialMix) * speed;
            p.vy = (dirY + tanY * tangentialMix) * speed;

            const colorJitter = (Math.random() - 0.5) * 0.25 * jitter;
            p.col = this.paletteColor((Math.random() + colorJitter + 1) % 1);
        }
    }

    updateParticles (dt, w, h)
    {
        const drag = lerp(0.9, 2.2, this.randomnessSmooth);
        const damp = Math.max(0, 1 - drag * dt);
        const margin = 24;
        const cx = w * 0.5;
        const cy = h * 0.5;

        for (let i = 0; i &lt; this.particles.length; i++)
        {
            const p = this.particles[i];
            if (!p.alive) continue;

            p.wobblePhase += dt * p.wobbleRate;
            const wobble = Math.sin(p.wobblePhase) * p.wobbleAmp;
            const tx = -p.dirY;
            const ty = p.dirX;

            p.vx += tx * wobble * dt;
            p.vy += ty * wobble * dt;

            p.vx *= damp;
            p.vy *= damp;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.rot += p.spin * dt;
            p.age += dt;

            const dx = p.x - cx;
            const dy = p.y - cy;
            const radius = Math.sqrt(dx * dx + dy * dy);

            if (p.age &gt;= p.life
                || radius &gt;= p.maxRadius
                || p.x &lt; -margin || p.x &gt; (w + margin)
                || p.y &lt; -margin || p.y &gt; (h + margin))
            {
                p.alive = false;
            }
        }
    }

    drawParticleShape (ctx, p, shapeId)
    {
        if (shapeId === 1)
        {
            ctx.arc(0, 0, p.size, 0, Math.PI * 2);
            return;
        }

        if (shapeId === 2)
        {
            const s = p.size * 1.65;
            ctx.rect(-s * 0.5, -s * 0.5, s, s);
            return;
        }

        if (shapeId === 0)
        {
            const r = p.size * 1.3;
            ctx.moveTo(0, -r);
            ctx.lineTo(r * 0.86, r * 0.5);
            ctx.lineTo(-r * 0.86, r * 0.5);
            ctx.closePath();
            return;
        }

        const spikes = 5;
        const outer = p.size * 1.45;
        const inner = outer * 0.5;
        for (let i = 0; i &lt; spikes * 2; i++)
        {
            const rr = (i % 2 === 0) ? outer : inner;
            const a = -Math.PI * 0.5 + i * (Math.PI / spikes);
            const x = Math.cos(a) * rr;
            const y = Math.sin(a) * rr;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
    }

    drawParticles (ctx, shapeId)
    {
        const glowBoost = 0.45 + this.stableIntensity * 0.85;
        const blurMin = 4;
        const blurMax = 18;
        const prevComp = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = &quot;lighter&quot;;

        for (let i = 0; i &lt; this.particles.length; i++)
        {
            const p = this.particles[i];
            if (!p.alive) continue;

            const lifeT = clamp01(p.age / Math.max(0.001, p.life));
            const alpha = (1 - lifeT) * (0.20 + this.stableIntensity * 0.8);
            if (alpha &lt;= 0.002) continue;

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot);
            ctx.beginPath();
            this.drawParticleShape(ctx, p, shapeId);

            const col = p.col;
            ctx.fillStyle = rgbToString(col, alpha * glowBoost);
            ctx.shadowColor = rgbToString(col, alpha * 0.9);
            ctx.shadowBlur = lerp(blurMin, blurMax, clamp01((p.size - 1.5) / 5.0));
            ctx.fill();
            ctx.restore();
        }

        ctx.globalCompositeOperation = prevComp;
        ctx.shadowBlur = 0;
    }

    draw (dt)
    {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;

        this.energySmooth = this.smoothToward(this.energySmooth, this.energy, 7.5, dt);
        this.randomnessSmooth = this.smoothToward(this.randomnessSmooth, this.params.randomness, 4.4, dt);

        const onset = clamp01((this.energySmooth - this.energySmoothPrev) * 9.0);
        this.energySmoothPrev = this.energySmooth;

        const randomRate = lerp(0.12, 1.45, this.params.randomness);
        const randDepth = lerp(0.02, 0.28, this.params.randomness);

        const pulse = Math.sin(this.colorPhase * 0.71) * randDepth;
        this.stablePalette = this.smoothToward(this.stablePalette, clamp01(this.params.palette + pulse), randomRate, dt);

        const energyPush = this.energySmooth * 0.28;
        const intensityTarget = clamp01(this.params.intensity + energyPush + Math.sin(this.colorPhase * 0.37) * (randDepth * 0.6));
        this.stableIntensity = this.smoothToward(this.stableIntensity, intensityTarget, randomRate * 0.75, dt);

        const shapeWobble = Math.sin(this.shapePhase) * randDepth * 0.34;
        this.stableShape = this.smoothToward(this.stableShape, clamp01(this.params.shape + shapeWobble), randomRate * 0.58, dt);

        const shapeId = Math.max(0, Math.min(3, Math.round(this.stableShape * 3)));

        const phaseDrive = clamp01(this.stableIntensity * 0.7 + this.params.randomness * 0.3);
        const phaseCurve = Math.pow(phaseDrive, 1.85);
        const randomCurve = Math.pow(clamp01(this.params.randomness), 1.6);
        const rotDrive = clamp01(this.stableIntensity * 0.65 + this.params.randomness * 0.2 + this.energySmooth * 0.15);
        const rotCurve = Math.pow(rotDrive, 1.7);

        this.colorPhase += dt * lerp(0.22, 1.35, phaseCurve);
        this.shapePhase += dt * lerp(0.12, 0.8, randomCurve);
        this.rot += dt * lerp(0.05, 0.58, rotCurve);
        this.bgTime += dt;

        const cx = w * 0.5;
        const cy = h * 0.5;
        const baseRadius = Math.min(w, h) * 0.30;
        const amp = (7 + this.stableIntensity * 40 + this.energySmooth * 24);

        this.spawnCooldown = Math.max(0, this.spawnCooldown - dt);
        if (onset &gt; 0.08 &amp;&amp; this.spawnCooldown &lt;= 0)
        {
            this.spawnParticles(onset, shapeId, cx, cy, baseRadius, w, h);
            this.spawnCooldown = lerp(0.03, 0.065, this.randomnessSmooth * 0.55);
        }
        this.updateParticles(dt, w, h);

        ctx.clearRect(0, 0, w, h);
        const breath = (Math.sin(this.bgTime * this.bgSweepHz * Math.PI * 2) + 1) * 0.5;
        const breathGray = Math.round(lerp(0, 5, breath));
        const atPeak = breath &gt;= 0.985;

        ctx.fillStyle = &#96;rgb(${breathGray}, ${breathGray}, ${breathGray})&#96;;
        ctx.fillRect(0, 0, w, h);

        const sweepWidth = Math.max(32, w * 0.22);
        const sweepX = ((this.bgTime * this.bgSweepHz) % 1) * (w + sweepWidth) - sweepWidth;
        const sweep = ctx.createLinearGradient(sweepX, 0, sweepX + sweepWidth, 0);

        if (atPeak)
        {
            sweep.addColorStop(0, &quot;rgba(7,5,7,0)&quot;);
            sweep.addColorStop(0.5, &quot;rgba(7,5,7,0.92)&quot;);
            sweep.addColorStop(1, &quot;rgba(7,5,7,0)&quot;);
        }
        else
        {
            sweep.addColorStop(0, &quot;rgba(5,5,5,0)&quot;);
            sweep.addColorStop(0.5, &quot;rgba(5,5,5,0.72)&quot;);
            sweep.addColorStop(1, &quot;rgba(5,5,5,0)&quot;);
        }

        ctx.fillStyle = sweep;
        ctx.fillRect(0, 0, w, h);

        const contourPulse = 1 + Math.sin(this.colorPhase * 0.92) * (0.02 + this.stableIntensity * 0.08);

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(this.rot * (0.3 + this.stableIntensity * 0.9));

        const samples = 360;
        for (let layer = 0; layer &lt; 2; layer++)
        {
            ctx.beginPath();
            for (let i = 0; i &lt;= samples; i++)
            {
                const t = i / samples;
                const p = this.sampleShape(shapeId, t, baseRadius * contourPulse);
                const nx = p[0] / Math.max(1, baseRadius);
                const ny = p[1] / Math.max(1, baseRadius);
                const nLen = Math.sqrt(nx * nx + ny * ny) || 1;
                const ox = nx / nLen;
                const oy = ny / nLen;

                const wig = Math.sin((t * Math.PI * 2 * (4 + layer * 2)) + this.colorPhase * (2.1 + layer * 0.6));
                const jitter = Math.sin((t * Math.PI * 2 * (11 + layer)) + this.shapePhase) * (0.25 + this.params.randomness * 0.5);
                const d = (wig + jitter) * amp * (0.55 + layer * 0.35);

                const x = p[0] + ox * d;
                const y = p[1] + oy * d;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const col = this.paletteColor((layer * 0.33 + this.colorPhase * 0.08) % 1);
            const alpha = layer === 0 ? 0.9 : 0.42;
            ctx.strokeStyle = rgbToString(col, alpha);
            ctx.lineWidth = layer === 0 ? (2.3 + this.stableIntensity * 2.0) : (8 + this.stableIntensity * 5.5);
            if (layer === 1)
            {
                ctx.shadowColor = rgbToString(col, 0.36);
                ctx.shadowBlur = 14 + this.stableIntensity * 24;
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        ctx.restore();

        this.drawParticles(ctx, shapeId);

        const label = this.shapeNames[shapeId] || &quot;Shape&quot;;
        if (this.labelEl)
            this.labelEl.textContent = `${label} Â· Palette ${(Math.round(this.stablePalette * 3) + 1)}`;
    }
}

// ======================================================
// Patch View (4 knobs)
// ======================================================

class VisualizerPatchView extends HTMLElement
{
    constructor (patchConnection)
    {
        super();
        this.patchConnection = patchConnection;
        this.className = &quot;ui-root&quot;;

        this.paramSpecs = [
            { id: &quot;param1&quot;,  label: &quot;Palette&quot;,    min: 0, max: 1, step: 0.01, init: 0.10, kind: &quot;float&quot; },
            { id: &quot;param2&quot;,  label: &quot;Intensity&quot;,  min: 0, max: 1, step: 0.01, init: 0.55, kind: &quot;float&quot; },
            { id: &quot;param3&quot;,  label: &quot;Shape&quot;,      min: 0, max: 1, step: 0.01, init: 0.20, kind: &quot;float&quot; },
            { id: &quot;param4&quot;,  label: &quot;Randomness&quot;, min: 0, max: 1, step: 0.01, init: 0.25, kind: &quot;float&quot; }
        ];

        this.innerHTML = this.getHTML();
        this.controls = new Map();

        this.paramListener = null;
        this.endpointUnsub = [];

        this.visualizer = null;
        this.endpointFrameSize = 256;

        this.outputEndpointListener = (payload) =&gt;
        {
            const { mono, sampleRate } = normalizeAudioChunk(payload);
            if (this.visualizer &amp;&amp; sampleRate) this.visualizer.sampleRate = sampleRate;
            if (this.visualizer &amp;&amp; mono &amp;&amp; mono.length &gt; 0)
                this.visualizer.pushMonoSamples(mono);
        };

        this.onWindowFocus = () =&gt; this.handleWake();
        this.onPageShow = () =&gt; this.handleWake();
        this.onVisibilityChange = () =&gt; { if (!document.hidden) this.handleWake(); };
    }

    connectedCallback()
    {
        const canvas = this.querySelector(&quot;.viz-canvas&quot;);
        const label = this.querySelector(&quot;.picked-label&quot;);
        this.visualizer = new ParticleVisualizer(canvas, label);

        const controlNodes = this.querySelectorAll(&quot;.control&quot;);
        controlNodes.forEach((controlNode) =&gt;
        {
            const param = controlNode.dataset.param;
            const spec = this.paramSpecs.find((s) =&gt; s.id === param);
            if (!spec) return;

            const knob = controlNode.querySelector(&quot;.knob&quot;);
            const valueLabel = controlNode.querySelector(&quot;.control-value&quot;);
            if (!knob || !valueLabel) return;

            const dial = new DialControl({
                patchConnection: this.patchConnection,
                param,
                knob,
                valueLabel,
                min: Number(spec.min),
                max: Number(spec.max),
                step: Number(spec.step),
                defaultValue: Number(spec.init),
                formatValue: (value) =&gt; this.formatValue(spec, value),
                onChange: (value) =&gt; this.onDialChange(spec, value)
            });

            this.controls.set(param, dial);
            this.patchConnection.requestParameterValue(param);
            this.onDialChange(spec, Number(spec.init));
        });

        this.paramListener = (event) =&gt;
        {
            const control = this.controls.get(event.endpointID);
            if (!control) return;
            control.setValue(Number(event.value), false);

            const spec = this.paramSpecs.find((s) =&gt; s.id === event.endpointID);
            if (spec)
                this.onDialChange(spec, Number(event.value));
        };
        this.patchConnection.addAllParameterListener(this.paramListener);

        window.addEventListener(&quot;focus&quot;, this.onWindowFocus);
        window.addEventListener(&quot;pageshow&quot;, this.onPageShow);
        document.addEventListener(&quot;visibilitychange&quot;, this.onVisibilityChange);

        this.handleWake();
    }

    disconnectedCallback()
    {
        this.controls.forEach((c) =&gt; c.cancelDrag());

        if (this.paramListener)
            this.patchConnection.removeAllParameterListener(this.paramListener);

        window.removeEventListener(&quot;focus&quot;, this.onWindowFocus);
        window.removeEventListener(&quot;pageshow&quot;, this.onPageShow);
        document.removeEventListener(&quot;visibilitychange&quot;, this.onVisibilityChange);

        this.detachOutputEndpointListener();

        if (this.visualizer)
        {
            this.visualizer.destroy();
            this.visualizer = null;
        }
    }

    onDialChange (spec, value)
    {
        if (!this.visualizer) return;

        if (spec.id === &quot;param1&quot;)  this.visualizer.setParam(&quot;palette&quot;, value);
        if (spec.id === &quot;param2&quot;)  this.visualizer.setParam(&quot;intensity&quot;, value);
        if (spec.id === &quot;param3&quot;)  this.visualizer.setParam(&quot;shape&quot;, value);
        if (spec.id === &quot;param4&quot;)  this.visualizer.setParam(&quot;randomness&quot;, value);
    }

    attachOutputEndpointListener()
    {
        this.detachOutputEndpointListener();

        if (!this.patchConnection || !this.outputEndpointListener)
            return;

        const unsubOut = this.patchConnection.addEndpointListener(&quot;out&quot;, this.outputEndpointListener, this.endpointFrameSize, true);
        if (typeof unsubOut === &quot;function&quot;)
            this.endpointUnsub.push(unsubOut);
    }

    detachOutputEndpointListener()
    {
        for (const fn of this.endpointUnsub)
            try { fn(); } catch (_) {}
        this.endpointUnsub = [];

        if (this.patchConnection &amp;&amp; this.outputEndpointListener)
        {
            try { this.patchConnection.removeEndpointListener(&quot;out&quot;, this.outputEndpointListener); }
            catch (_) {}
        }
    }

    handleWake()
    {
        if (this.visualizer)
            this.visualizer.wake();

        if (!document.hidden)
            this.attachOutputEndpointListener();
    }

    getDecimals (step)
    {
        if (!Number.isFinite(step) || step &lt;= 0) return 2;
        const text = String(step);
        const dot = text.indexOf(&quot;.&quot;);
        if (dot &lt; 0) return 0;
        return Math.min(6, text.length - dot - 1);
    }

    formatValue (spec, value)
    {
        const min = Number.isFinite(spec.min) ? spec.min : 0;
        const max = Number.isFinite(spec.max) ? spec.max : 1;
        const v = Math.max(min, Math.min(max, Number.isFinite(value) ? value : spec.init));


        const decimals = this.getDecimals(spec.step);
        return v.toFixed(decimals);
    }

    escapeHTML (text)
    {
        return String(text)
            .replaceAll(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
            .replaceAll(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
            .replaceAll(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
            .replaceAll(&quot;\&quot;&quot;, &quot;&amp;quot;&quot;)
            .replaceAll(&quot;'&quot;, &quot;&amp;#39;&quot;);
    }

    getHTML()
    {
        const controls = this.paramSpecs.map((spec) =&gt;
            &#96;&lt;div class=&quot;control&quot; data-param=&quot;${spec.id}&quot; data-min=&quot;${spec.min}&quot; data-max=&quot;${spec.max}&quot; data-step=&quot;${spec.step}&quot; data-init=&quot;${spec.init}&quot;&gt;
                &lt;div class=&quot;knob&quot;&gt;
                    &lt;div class=&quot;knob-track&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;knob-fill&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;knob-core&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;knob-pointer&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;control-value&quot;&gt;${this.formatValue(spec, spec.init)}&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;control-label&quot;&gt;${this.escapeHTML(spec.label)}&lt;/div&gt;
            &lt;/div&gt;&#96;).join(&quot;&quot;);

        return &#96;
            &lt;style&gt;
                .ui-root, .ui-root * {
                    box-sizing: border-box;
                    font-family: &quot;Space Grotesk&quot;, system-ui, sans-serif;
                    user-select: none;
                    -webkit-user-select: none;
                }

                .ui-shell {
                    min-height: 100%;
                    padding: 16px;
                    color: #dfe4eb;
                    background: radial-gradient(900px 520px at 8% -4%, #2a313c 0%, #1b212b 52%, #151a22 100%);
                    display: grid;
                    grid-template-rows: auto auto;
                    gap: 14px;
                }

                .title {
                    margin: 0;
                    letter-spacing: 0.08em;
                    text-transform: uppercase;
                    font-size: 12px;
                    color: #9ca6b4;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 10px;
                }

                .picked-label {
                    font-size: 11px;
                    letter-spacing: 0.03em;
                    color: rgba(220, 232, 248, 0.85);
                    text-transform: none;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    max-width: 70%;
                }

                .viz-wrap {
                    position: relative;
                    width: 100%;
                    aspect-ratio: 1 / 1;
                    border-radius: 16px;
                    overflow: hidden;
                    border: 1px solid rgba(141, 159, 184, 0.20);
                    background: linear-gradient(180deg, rgba(10, 14, 21, 0.55), rgba(0,0,0,0.18));
                    box-shadow: inset 0 1px 1px rgba(255,255,255,0.05);
                }

                .viz-canvas {
                    width: 100%;
                    height: 100%;
                    display: block;
                }

                .controls-grid {
                    display: grid;
                    grid-template-columns: repeat(4, minmax(0, 1fr));
                    gap: 14px;
                }

                @media (max-width: 720px) {
                    .controls-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
                    .picked-label { max-width: 58%; }
                }

                .control {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 10px;
                    padding: 8px 6px 4px;
                }

                .ui-root.is-dragging,
                .ui-root.is-dragging * {
                    cursor: default !important;
                }

                .knob {
                    position: relative;
                    width: 72px;
                    height: 72px;
                    --angle: -135deg;
                    --norm: 0;
                    touch-action: none;
                    -webkit-tap-highlight-color: transparent;
                }

                .knob-track,
                .knob-fill,
                .knob-core {
                    position: absolute;
                    border-radius: 50%;
                }

                .knob-track,
                .knob-fill {
                    inset: 0;
                    --ring-thickness: 5px;
                    -webkit-mask: radial-gradient(farthest-side, transparent calc(100% - var(--ring-thickness)), #000 calc(100% - var(--ring-thickness)));
                    mask: radial-gradient(farthest-side, transparent calc(100% - var(--ring-thickness)), #000 calc(100% - var(--ring-thickness)));
                }

                .knob-track {
                    background: conic-gradient(from -135deg, rgba(176, 193, 216, 0.18) 0deg 270deg, transparent 270deg 360deg);
                }

                .knob-fill {
                    background: conic-gradient(
                        from -135deg,
                        rgba(178, 200, 229, 0.45) 0deg,
                        #dce7f5 calc(var(--norm) * 270deg),
                        transparent calc(var(--norm) * 270deg) 360deg
                    );
                    filter: drop-shadow(0 0 5px rgba(220, 232, 248, 0.22));
                }

                .knob-core {
                    inset: 6px;
                    background: linear-gradient(180deg, rgba(18, 23, 32, 0.86) 0%, rgba(10, 14, 21, 0.92) 100%);
                    border: 1px solid rgba(141, 159, 184, 0.26);
                    box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.08), 0 1px 2px rgba(0, 0, 0, 0.35);
                }

                .knob-pointer {
                    display: none !important;
                    pointer-events: none;
                }

                .control-value {
                    position: absolute;
                    inset: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 0 7px;
                    font-size: 11px;
                    font-weight: 600;
                    letter-spacing: 0.03em;
                    color: #dce7f7;
                    text-align: center;
                    text-shadow: 0 0 8px rgba(220, 232, 248, 0.2);
                    pointer-events: none;
                }

                .control-label {
                    font-size: 12px;
                    letter-spacing: 0.05em;
                    text-transform: uppercase;
                    color: #c5ccd7;
                    text-align: center;
                    min-height: 14px;
                }
            &lt;/style&gt;

            &lt;div class=&quot;ui-shell&quot;&gt;
                &lt;div class=&quot;title&quot;&gt;
                    &lt;span&gt;Visualizer&lt;/span&gt;
                    &lt;span class=&quot;picked-label&quot;&gt;&#8212;&lt;/span&gt;
                &lt;/div&gt;

                &lt;div class=&quot;viz-wrap&quot;&gt;
                    &lt;canvas class=&quot;viz-canvas&quot;&gt;&lt;/canvas&gt;
                &lt;/div&gt;

                &lt;div class=&quot;controls-grid&quot;&gt;${controls}&lt;/div&gt;
            &lt;/div&gt;
        &#96;;
    }
}

export default function createPatchView (patchConnection)
{
    const name = &quot;amorph-visualizer-shape-wave-v1&quot;;
    if (!window.customElements.get(name))
        window.customElements.define(name, VisualizerPatchView);

    return new (window.customElements.get(name)) (patchConnection);
}
</UICode>
</AmorphAlgorithm>
